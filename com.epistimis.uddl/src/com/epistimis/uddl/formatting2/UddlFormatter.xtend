/*
 * generated by Xtext 2.28.0
 */
package com.epistimis.uddl.formatting2

import com.epistimis.uddl.services.UddlGrammarAccess
import com.epistimis.uddl.uddl.ConceptualDataModel
import com.epistimis.uddl.uddl.DataModel
import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.common.util.EList
import com.epistimis.uddl.uddl.LogicalDataModel
import com.epistimis.uddl.uddl.LogicalCoordinateSystem
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import static com.epistimis.uddl.uddl.UddlPackage.Literals.*

class UddlFormatter extends AbstractFormatter2 {
	
	@Inject extension UddlGrammarAccess

	/**
	 * Several standard methods needed for formatting
	 * 1) All objects will have 
	 * 		A) '{' and '};' on a newline. 
	 * 		B) All content inside the '{' and '}' will be indented one tab
	 * 
	 * NOTES: Because we don't know the structure of the object, we don't know how to format its
	 * content. So we format the open and close separately
	 * 
	 * 2) '{' and '}' for scoping means
	 * 		A) all content indented one tab further
	 * 		B) '{' on newline after name/description of scope
	 * 
	 * 3) '[' and ']' for lists means
	 * 		A) all list content have 1 space between
	 * 		B) '[', ']' and content all on the same line
	 * 
	 * 
	 */
//	protected <O extends EObject> void formatObjOpen(O obj, IFormattableDocument doc) {
//		obj.
//		
//	}
//	protected <O extends EObject> void formatObjClose(O obj, IFormattableDocument doc) {
//		
//	}
//	
//	protected <L extends EList<EObject>> void formatList(L list, IFormattableDocument doc) {
//		
//	}
//
//	protected  <C extends EObject> void formatContainer(C container, IFormattableDocument doc) {
//		
//	}
	def void objOpen(EObject obj, extension IFormattableDocument document) {
		obj.regionFor.keyword('{').prepend[newLine];		
	}
	def void objClose(EObject obj, extension IFormattableDocument document) {
		obj.regionFor.keyword('}').surround[noSpace];		
		obj.regionFor.keyword(';').append[newLine];		
	}

	def void formatContainerContents(EList<EObject> objs, extension IFormattableDocument document) {
		for (obj : objs) { 
			obj.append[setNewLines(1, 1, 2)]
		}			
	}	
	
	def void formatContainer(EObject obj, extension IFormattableDocument document) {
		val open = obj.regionFor.keyword("{") 
		val close = obj.regionFor.keyword("}") 
		open.append[newLine]
		interior(open, close)[indent]			
	}	
	def void formatObj(EObject obj, extension IFormattableDocument document) {
		obj.formatContainer(document);
		
		obj.regionFor.keyword('}').surround[noSpace];		
		obj.regionFor.keyword(';').append[newLine];		
	}
	
	def void formmatListContainer(EObject obj, EList<EObject> contents, extension IFormattableDocument document) {
		obj.regionFor.keyword("[").surround[oneSpace]; 
		obj.regionFor.keyword("]").surround[oneSpace]; 
		contents.formatList(document);	
		
	}
	def void formatList(EList<EObject> objs, extension IFormattableDocument document) {	
		for (EObject obj: objs) {
			obj.surround[oneSpace]
		}
	}
	
	
	def void formatAttribute(ISemanticRegion attrStart, ISemanticRegion attrEnd ,  extension IFormattableDocument document) {
		attrStart.prepend[newLine]
		attrEnd.append[newLine]
	}
	
	
	def dispatch void format(DataModel dataModel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (conceptualDataModel : dataModel.cdm) {
			conceptualDataModel.format
		}
		for (logicalDataModel : dataModel.ldm) {
			logicalDataModel.format
		}
		for (platformDataModel : dataModel.pdm) {
			platformDataModel.format
		}
	}

	def dispatch void format(ConceptualDataModel conceptualDataModel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		conceptualDataModel.formatContainer(document);

		for (conceptualElement : conceptualDataModel.element) {
			conceptualElement.append[setNewLines(1, 1, 2)]
			conceptualElement.format
		}
		for (_conceptualDataModel : conceptualDataModel.cdm) {
			_conceptualDataModel.append[setNewLines(1, 1, 2)]
			_conceptualDataModel.format
		}
	}

	def dispatch void format(LogicalDataModel logicalDataModel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		logicalDataModel.formatContainer(document);

		for (logicalElement : logicalDataModel.element) {
			logicalElement.append[setNewLines(1, 1, 2)]
			logicalElement.format
		}
		for (_logicalDataModel : logicalDataModel.ldm) {
			_logicalDataModel.append[setNewLines(1, 1, 2)]
			_logicalDataModel.format
		}
	}
	
	def dispatch void format(LogicalCoordinateSystem lcs, extension IFormattableDocument document) {
		lcs.formatObj(document);
		formatAttribute(lcs.regionFor.keyword('axis:'),lcs.regionFor.feature(LOGICAL_COORDINATE_SYSTEM__AXIS_RELATIONSHIP_DESCRIPTION),document);
		formatAttribute(lcs.regionFor.keyword('angleEq:'),lcs.regionFor.feature(LOGICAL_COORDINATE_SYSTEM__ANGLE_EQUATION),document);
		formatAttribute(lcs.regionFor.keyword('distanceEq:'),lcs.regionFor.feature(LOGICAL_COORDINATE_SYSTEM__DISTANCE_EQUATION),document);
		formatAttribute(lcs.regionFor.keyword('['),lcs.regionFor.keyword(']'),document); // for list of axes
		for (EObject obj: lcs.axis) {
			obj.surround[oneSpace]
		}
		
	}
	// TODO: implement for LogicalDataModel, PlatformDataModel, ConceptualEntity, ConceptualAssociation, ConceptualParticipant, ConceptualParticipantPathNode, ConceptualCharacteristicPathNode, ConceptualCompositeQuery, LogicalEnumerated, LogicalMeasurementSystem, LogicalMeasurementSystemAxis, LogicalReferencePoint, LogicalValueTypeUnit, LogicalMeasurement, LogicalEntity, LogicalAssociation, LogicalParticipant, LogicalParticipantPathNode, LogicalCharacteristicPathNode, LogicalCompositeQuery, PlatformStruct, PlatformEntity, PlatformAssociation, PlatformParticipant, PlatformParticipantPathNode, PlatformCharacteristicPathNode, PlatformCompositeQuery
}
